
// This feature enables signal sending when pressed. 

// the following snippets are to be further tested with the VNA. 


// SNIPPET 1. From Stack Overflow. 

// The only error is related to Online IDE, which does not have the <iostream> included. 
// main.c:1:10: fatal error:  iostream: No such file or directory
//    1 | #include <iostream>
//    |          ^~~~~~~~~~  compilation terminated.

#include <iostream>
#include <functional>

using namespace std::placeholders;


class GenericButton
{
public:
    typedef std::function<void()> fPtr;
    GenericButton() : funcitonToCall(nullptr) {}
    void setTarget(fPtr target) {
        funcitonToCall = target;
    }

    void pressButton() {
        if (funcitonToCall) funcitonToCall();
    }

private:
    fPtr funcitonToCall;
};

struct foo {
    void doSomething() const {
        std::cout << "doing something in a foo..." << std::endl;
    }

    static void alternative(int i) {
        std::cout << "And another, i=" << i << "\n";
    }
};

void doSomethingElse() {
    std::cout << "doing something else..." << std::endl;
}

int main() {
    GenericButton myButton;
    foo f;
    myButton.setTarget(std::bind(&foo::doSomething, &f));
    myButton.pressButton();
    myButton.setTarget(doSomethingElse);
    myButton.pressButton();
    myButton.setTarget(std::bind(foo::alternative, 666));
    myButton.pressButton();
    myButton.setTarget([](){ std::cout << "Lambda!\n"; });
    myButton.pressButton();
}


// SNIPPET 2. From Stack Overflow == PSEUDOKOODIA !


Using asynchronous code or idle handlers should be the first option, and a worker 
thread is another (but please only add threads when you know that you actually need them). 
It's also possible to "pump" the event loop manually but that should really be 
the last option. See main loop reference for details.

Your example would look something like this:

gboolean check_connection (gpointer user_data)
{
    /* g_print what you want based on check value */

    if (check == 0)
        return FALSE;
    return TRUE;
}

void button1_clicked_do_job(GtkWidget *widget, gpointer data1)
{
     g_timeout_add_seconds (2, check_connection, NULL);
}


// SNIPPET 3. JAVA CODE!  Client Server structure and how to make the similar communication protocol in general for microcontrollers.
However, JAVA does not run in Arduino and the data structure needs to be transformed as well, together with the methods. 


MAKE: PROJECTS 
Communicating in (Near) Real Time
So far, most of the networked communications you’ve seen worked through a web browser. Your device made a request 
to a remote server, the server ran a program, and then it sent a response. The client made a connection to 
the web server, exchanging some information, and then the connection was broken. In this chapter, you’ll learn 
how to keep that connection open. You’ll write two different server programs that allow you to maintain the 
connection in order to facilitate a faster and more consistent exchange between the server and client.

A Test Chat Server.  !!!!!!!!!!!!!!!

You need a server to get started. You don’t need code to control the video right now; you just want 
to confirm that the clients can connect and send messages. Following is a server written in Processing 
with all the elements to handle network communications. It will let you listen for new clients, and 
then send them messages by typing in the applet window that appears when you run the program.


Try It

Start with the includes and variable declarations and definitions. Include the net library, which 
gives you the ability to make socket connections, The main variables are an instance of the Server 
class, a port number on which to serve, and an ArrayList to keep track of the clients. You can make 
the new Server and ArrayList instances here when you initialize the variables, or you can do it in the setup() function.

/*
  Test Server Program
 Context: Processing
 
 Creates a server that listens for clients and prints
 what they say.  It also sends the last client anything that's
 typed on the keyboard.
 */
  
// include the net library:
import processing.net.*;
  
int port = 8080;                         // the port the server listens on
Server myServer = new Server(this, port); // the server object
ArrayList clients = new ArrayList();       // list of clients 
This program uses a Processing data type you may not have seen before: ArrayList. Think of it as a super-duper array. 
ArrayLists don’t have a fixed number of elements to begin with, so you can add new elements as the program continues. 
It’s useful when you don’t know how many elements you’ll have. In this case, you don’t know how many clients 
you’ll have, so you’ll store them in an ArrayList, and add each new client to the list as it connects. 
Processing inherits ArrayLists from Java. There is an introduction to ArrayLists on the Processing 
website at www.processing.org. JavaScript arrays are expandable like ArrayLists as well. 

Unfortunately, Arduino and C do not have expandable arrays. !!!!!!!!!!!!!!!!!!!!1

The setup() method sets the window size.

void setup() {
  size(640, 360);                    // set the window size
}
The draw() method listens for new messages from clients and calls a function called readMessage() to deal with them.

void draw() {
  // listen for clients:
  Client currentClient = myServer.available();
  
  // if a client sends a message, read it:
  if (currentClient != null ) {
    readMessage(currentClient);
  }
}
The readMessage() function handles incoming messages. It skips empty messages (strings with just a newline, 
for example) and prints the message and the sender’s IP address. If a client sends any message containing 
the substring “exit,” the server disconnects it and removes it from the list of clients.

void readMessage(Client thisClient) {
  // read available text from client as a String and print it:
  String message = thisClient.readStringUntil('\n');
  // if there's no message, skip the rest of this function:
  if (message == null) return;
  // print the message and who it's from
  println(thisClient.ip() + ": " + message);  
  
  if (message.contains("exit")) {    // if it's a disconnect message, 
    myServer.disconnect(thisClient); // disconnect client  
    clients.remove(thisClient);      // delete client from the clientList
  }
}
The serverEvent() message is generated by the server when a new client connects to it. serverEvent() 
announces new clients and adds them to the client list. It sends the new client the greeting message 
telling it its place in the clients ArrayList.

// ServerEvent occurs when a new client connects to the server:
void serverEvent(Server myServer, Client thisClient) {
  println("New client: " + thisClient.ip()); // print client's IP
  clients.add(thisClient);                   // add it to the clientList
  thisClient.write("client:" + clients.size() + "\n");     // say hello
}
Finally, the keyReleased() method sends any keystrokes typed on the server to all connected clients. This is just for testing.

void keyReleased() {
    myServer.write(key);
}
Run the server and open a telnet connection to it. Remember, it’s listening on port 8080, so if your computer’s IP 
address is, say, 192.168.1.45, you’d connect like so: telnet 192.168.1.45 8080. If you’re telnetting in from the 
same machine, you can use: telnet localhost 8080 or telnet 127.0.0.1 8080. (Windows 10 users: telnet may ask for 
password permission to connect). Whatever you type in the telnet window will show up in Processing’s console pane 
when you press Enter, and whatever you type in the server’s applet window will show up at the client’s command line. 
Try sending the messages as described previously: playing, position, and exit. Sending exit:1 will cause 
the server to close the connection to the client.

Once you understand the server, it’s time to make a microcontroller-based client to connect to it.
However, our Use Case needs (for the time being) a single one-way communication as no ACK is required!
VNA is used to measure, that the SIGNAL pressButton function does the job. 



Snippet 4.) Investigate which of the below libraries are being needed, 

// include required libraries and config files
#include <SPI.h>
#include <WiFi101.h>     (This at least seems to be relevant ATM). 
#include <Encoder.h>
#include <Button.h>
#include "config.h"     



