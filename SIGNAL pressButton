
// This feature enables signal sending when pressed. 

// the following snippets are to be further tested with the VNA. 


// SNIPPET 1. From Stack Overflow. 

// The only error is related to Online IDE, which does not have the <iostream> included. 
// main.c:1:10: fatal error:  iostream: No such file or directory
//    1 | #include <iostream>
//    |          ^~~~~~~~~~  compilation terminated.

#include <iostream>
#include <functional>

using namespace std::placeholders;


class GenericButton
{
public:
    typedef std::function<void()> fPtr;
    GenericButton() : funcitonToCall(nullptr) {}
    void setTarget(fPtr target) {
        funcitonToCall = target;
    }

    void pressButton() {
        if (funcitonToCall) funcitonToCall();
    }

private:
    fPtr funcitonToCall;
};

struct foo {
    void doSomething() const {
        std::cout << "doing something in a foo..." << std::endl;
    }

    static void alternative(int i) {
        std::cout << "And another, i=" << i << "\n";
    }
};

void doSomethingElse() {
    std::cout << "doing something else..." << std::endl;
}

int main() {
    GenericButton myButton;
    foo f;
    myButton.setTarget(std::bind(&foo::doSomething, &f));
    myButton.pressButton();
    myButton.setTarget(doSomethingElse);
    myButton.pressButton();
    myButton.setTarget(std::bind(foo::alternative, 666));
    myButton.pressButton();
    myButton.setTarget([](){ std::cout << "Lambda!\n"; });
    myButton.pressButton();
}


// SNIPPET 2. From Stack Overflow == PSEUDOKOODIA !


Using asynchronous code or idle handlers should be the first option, and a worker 
thread is another (but please only add threads when you know that you actually need them). 
It's also possible to "pump" the event loop manually but that should really be 
the last option. See main loop reference for details.

Your example would look something like this:

gboolean check_connection (gpointer user_data)
{
    /* g_print what you want based on check value */

    if (check == 0)
        return FALSE;
    return TRUE;
}

void button1_clicked_do_job(GtkWidget *widget, gpointer data1)
{
     g_timeout_add_seconds (2, check_connection, NULL);
}


// SNIPPET 3. JAVA CODE!  Client Server structure and how to make the similar communication protocol in general for microcontrollers.
However, JAVA does not run in Arduino and the data structure needs to be transformed as well, together with the methods. 


MAKE: PROJECTS 
Communicating in (Near) Real Time
So far, most of the networked communications you’ve seen worked through a web browser. Your device made a request 
to a remote server, the server ran a program, and then it sent a response. The client made a connection to 
the web server, exchanging some information, and then the connection was broken. In this chapter, you’ll learn 
how to keep that connection open. You’ll write two different server programs that allow you to maintain the 
connection in order to facilitate a faster and more consistent exchange between the server and client.

A Test Chat Server.  !!!!!!!!!!!!!!!

You need a server to get started. You don’t need code to control the video right now; you just want 
to confirm that the clients can connect and send messages. Following is a server written in Processing 
with all the elements to handle network communications. It will let you listen for new clients, and 
then send them messages by typing in the applet window that appears when you run the program.


Try It

Start with the includes and variable declarations and definitions. Include the net library, which 
gives you the ability to make socket connections, The main variables are an instance of the Server 
class, a port number on which to serve, and an ArrayList to keep track of the clients. You can make 
the new Server and ArrayList instances here when you initialize the variables, or you can do it in the setup() function.

/*
  Test Server Program
 Context: Processing
 
 Creates a server that listens for clients and prints
 what they say.  It also sends the last client anything that's
 typed on the keyboard.
 */
  
// include the net library:
import processing.net.*;
  
int port = 8080;                         // the port the server listens on
Server myServer = new Server(this, port); // the server object
ArrayList clients = new ArrayList();       // list of clients 
This program uses a Processing data type you may not have seen before: ArrayList. Think of it as a super-duper array. 
ArrayLists don’t have a fixed number of elements to begin with, so you can add new elements as the program continues. 
It’s useful when you don’t know how many elements you’ll have. In this case, you don’t know how many clients 
you’ll have, so you’ll store them in an ArrayList, and add each new client to the list as it connects. 
Processing inherits ArrayLists from Java. There is an introduction to ArrayLists on the Processing 
website at www.processing.org. JavaScript arrays are expandable like ArrayLists as well. 

Unfortunately, Arduino and C do not have expandable arrays. !!!!!!!!!!!!!!!!!!!!1

The setup() method sets the window size.

void setup() {
  size(640, 360);                    // set the window size
}
The draw() method listens for new messages from clients and calls a function called readMessage() to deal with them.

void draw() {
  // listen for clients:
  Client currentClient = myServer.available();
  
  // if a client sends a message, read it:
  if (currentClient != null ) {
    readMessage(currentClient);
  }
}
The readMessage() function handles incoming messages. It skips empty messages (strings with just a newline, 
for example) and prints the message and the sender’s IP address. If a client sends any message containing 
the substring “exit,” the server disconnects it and removes it from the list of clients.

void readMessage(Client thisClient) {
  // read available text from client as a String and print it:
  String message = thisClient.readStringUntil('\n');
  // if there's no message, skip the rest of this function:
  if (message == null) return;
  // print the message and who it's from
  println(thisClient.ip() + ": " + message);  
  
  if (message.contains("exit")) {    // if it's a disconnect message, 
    myServer.disconnect(thisClient); // disconnect client  
    clients.remove(thisClient);      // delete client from the clientList
  }
}
The serverEvent() message is generated by the server when a new client connects to it. serverEvent() 
announces new clients and adds them to the client list. It sends the new client the greeting message 
telling it its place in the clients ArrayList.

// ServerEvent occurs when a new client connects to the server:
void serverEvent(Server myServer, Client thisClient) {
  println("New client: " + thisClient.ip()); // print client's IP
  clients.add(thisClient);                   // add it to the clientList
  thisClient.write("client:" + clients.size() + "\n");     // say hello
}
Finally, the keyReleased() method sends any keystrokes typed on the server to all connected clients. This is just for testing.

void keyReleased() {
    myServer.write(key);
}
Run the server and open a telnet connection to it. Remember, it’s listening on port 8080, so if your computer’s IP 
address is, say, 192.168.1.45, you’d connect like so: telnet 192.168.1.45 8080. If you’re telnetting in from the 
same machine, you can use: telnet localhost 8080 or telnet 127.0.0.1 8080. (Windows 10 users: telnet may ask for 
password permission to connect). Whatever you type in the telnet window will show up in Processing’s console pane 
when you press Enter, and whatever you type in the server’s applet window will show up at the client’s command line. 
Try sending the messages as described previously: playing, position, and exit. Sending exit:1 will cause 
the server to close the connection to the client.

Once you understand the server, it’s time to make a microcontroller-based client to connect to it.
However, our Use Case needs (for the time being) a single one-way communication as no ACK is required!
VNA is used to measure, that the SIGNAL pressButton function does the job. 



Snippet 4.) Investigate which of the below libraries are being needed, 

// include required libraries and config files
#include <SPI.h>
#include <WiFi101.h>     (This at least seems to be relevant ATM). 
#include <Encoder.h>
#include <Button.h>
#include "config.h"     





// SNIPPET 5.  from the chapter 5. On line book. 


Set up global variables to hold the server address (your personal computer’s address, where the server runs) and make 
an instance of the WiFiClient library. This is how you’ll create a TCP socket connection to the server, and read from and write to the server.

const char serverAddress[] = "192.168.0.12"; // server address
Change this to match your server”s IP address
int port = 8080;                              // port number
WiFiClient tcpSocket;                         // server socket
  
Then make instances of the Encoder and Button libraries to read the encoder and buttons. Set up constants for 
the LED pin numbers to make them easier to remember as well. Finally, you need a Boolean variable to track the 
playing state, and a long integer to hold the last read encoder position.

    Encoder myEncoder(0, 1);         // instance of the encoder library
    Button playButton(2);            // instances of the button library
    Button connectButton(3);
    const int playLED = 4;           // pin numbers for the LEDs
    const int connectLED = 5;
  
    boolean playing = false;         // what the video state should be
    long lastPosition  = 0;          // last read position of the encoder

The setup() function sets the states of the I/O pins and starts the button instances.  !!!!!

Notice that the pinMode for 
the encoder pins is INPUT_PULLUP. This tells the microcontroller that you want to use the internal pullup 
resistors on these pins.

Once the pins are initialized, you’ll connect to your WiFi network, just like you did in the sketches in Chapter 4.

void setup() {
  Serial.begin(9600);             // initialize serial communication
  pinMode(0, INPUT_PULLUP);       // initialize encoder pins
  pinMode(1, INPUT_PULLUP);
  pinMode(connectLED, OUTPUT);    // initialize LED pins
  pinMode(playLED, OUTPUT);
  connectButton.begin();           // initialize buttons
  playButton.begin();
  
  // while you're not connected to a WiFi AP,
  while ( WiFi.status() != WL_CONNECTED) {
    Serial.print("Attempting to connect to Network named: ");
    Serial.println(ssid);           // print the network name (SSID)
    WiFi.begin(ssid, password);     // try to connect
    delay(2000);
  }
  
  // When you're connected, print out the device's network status:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);
}
The Encoder library relies on the interrupt function of the microcontroller to read the encoder pins. 
Hardware interrupts allow the controller to interrupt whatever is going on in the code when a given input 
pin changes. If interrupts interfere with the communication between the main processor on the MKR1000 and 
the WiFi radio, you can turn off the use of interrupts by using the #define ENCODER_DO_NOT_USE_INTERRUPTS 
directive before you include the library.

Begin the loop() function by calling two new functions, readEncoder() and readButtons(), which you’ll write 
shortly. These will do what their names imply. Then check to see if there’s a socket connection to the server, 
and if so, check if there’s any data available to be read from the server. If there is, read it and print it out 
to the Serial Monitor.

Finally, update the status LEDs. The Connect LED depends on whether there’s a socket connection, so you can use 
the value returned by the tcpSocket.connected() function, which returns 1 or 0 for true or false. Likewise, 
you can turn on or off the Playing LED using the playing variable, which you’ll set to true or false as well.

void loop() {
  // read the sensors:
  readEncoder();
  readButtons();
  
  // check for incoming data from the server:
  if (tcpSocket.connected()) {    // if connected to the server,
    if (tcpSocket.available()) {  // if there is a response from the server,
      String result = tcpSocket.readString();  // read it
      Serial.print(result);       // and print it (for diagnostics only)
    }
  }
  // update the status LEDs:
  digitalWrite(connectLED, tcpSocket.connected());
  digitalWrite(playLED, playing);
}
Start the readEncoder() function by calling myEncoder.read(). It will return the number of steps the encoder’s 
taken. Positive values indicate clockwise movement and negative values indicate counterclockwise movement. 
Compare the position to the last position read, and if there’s a socket connection to the server open, send 
the difference to the server. Then save the current position for comparison next time you read.

void readEncoder() {
  long position = myEncoder.read();       // read the encoder
  long difference = position - lastPosition;  // compare to last position
  if (difference != 0) {                  // if it's changed,
    if (tcpSocket.connected()) {          // if the socket's connected,
      tcpSocket.print("position:");        // send the key
      tcpSocket.println(difference);       // send the value
    }
    lastPosition = position;              // update lastPosition
  }
}
  
Start the readButtons() function by checking if the Connect button is toggled (changed), and if so, read it to see if it’s pressed. 
If so, and there’s no socket connection to the server, attempt to connect. If you’re connected, send exit:1 and the server will disconnect.

By determining if .toggled() is true and the button is low, you ensure that you’re only taking action when the button changes 
state. If you only checked if it was pressed, you’d take action repeatedly as long as it’s held down.

void readButtons() {
  if (connectButton.toggled()) {          // if connect button has changed
    if (connectButton.read() == LOW) {    // and it's pressed
      if (!tcpSocket.connected()) {       // if you're not connected,
        connectToServer();                // connect to server
      } else {                           // if you're already connected,
        tcpSocket.println("exit:1");       // disconnect
      }
    }
  }                                       // end of connectButton.toggled
  
Finish the readButtons() function by checking the Play button. Check both toggled and pressed conditions just like you did 
with the Connect button. If its state has changed, change the variable playing to its opposite, and if there’s a socket 
connection to the server, send a message with the current state of this variable.

  if (playButton.toggled()) {             // if the play button has changed
    if (playButton.read() == LOW) {       // and it's LOW
      playing = !playing;                 // toggle playing state
      if (tcpSocket.connected()) {        // if you're connected,
        tcpSocket.print("playing:");       // send the key
        tcpSocket.println(playing);        // send the value
      }
    }
  }                                       // end of playButton.toggled
}                                         // end of readButtons()

Finally, you need the connectToServer() function that’s called in the first half of readButtons(). 
This calls the .connect() function from the WiFiClient library to attempt a connection to the server. 
This is a blocking function, meaning that it stops your whole program until a connection is made. 
You’ll probably notice a delay between when you press the button and when the Serial Monitor reports the result.

void connectToServer() {
  Serial.println("attempting to connect");
  // attempt to connect to the server on the given port:
  if (tcpSocket.connect(serverAddress, port)) {
    Serial.println("connected");
  } else {
    Serial.println("failed to connect");
  }
}
Upload the client code to the microcontroller, then run the Processing chat server that you wrote previously. 
Open the Serial Monitor so you can see the status messages. Once your controller’s connected to WiFi, press 
the Connect button, and you should see it connect to the server. Click the Play button or turn the encoder, 
and you should see the messages come through in Processing’s console pane. If you type in the Processing 
sketch window and hit the Enter key, the message should show up in the Arduino Serial Monitor as well.
Congratulations, you’ve got a working client!

Send a few messages to the server by triggering the encoder and the buttons to get a sense how both 
the server and the controller client device work. Once you’re comfortable, it’s time to add video to the server application.
X


HARDWARE INTERRUPTS

Hardware interrupts allow a microcontroller to interrupt whatever is going on in the code when a given input pin changes. 
The interrupt function in this library’s examples (called an interrupt service routine or ISR) is internal to 
the Encoder library. You can read more about them on the Arduino reference site at www.arduino.cc/en/Reference/AttachInterrupt. 
The hardware interrupt pin numbers vary from processor to processor. The ATMega328 processor on the Uno has two interrupts,
numbered 0 and 1, attached to digital pins 2 and 3, respectively. On the 101 all the digital pins can be used as interrupts. 
On the MKR1000, pins 0, 1, 4, 5, 6, 7, 8, 9, A1, and A2 are interrupts. The digitalPinToInterrupt(pin) function 
translates the digital pin number to the interrupt number. For example, on the Uno, digitalPinToInterrupt(3) returns 1. 
This command doesn’t work on the 101, though, since it’s not needed on that controller.


